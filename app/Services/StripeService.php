<?php

namespace App\Services;

use Stripe\Stripe;
use Stripe\PaymentIntent;
use Stripe\Customer;
use Stripe\Webhook;
use App\Models\Order;
use App\Models\OrderLocation;
use App\Models\User;
use App\Models\Product;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Mail;

class StripeService
{
    public function __construct()
    {
        Stripe::setApiKey(config('services.stripe.secret'));
    }

    /**
     * Cr√©er un PaymentIntent pour un achat
     */
    public function createPaymentIntentForOrder(Order $order): PaymentIntent
    {
        $paymentIntent = PaymentIntent::create([
            'amount' => $this->convertToStripeAmount($order->total_amount),
            'currency' => 'eur',
            'description' => "Commande d'achat #{$order->order_number}",
            'metadata' => [
                'order_id' => $order->id,
                'order_type' => 'purchase',
                'order_number' => $order->order_number,
                'user_id' => $order->user_id,
                'user_email' => $order->user->email ?? ''
            ],
            'automatic_payment_methods' => [
                'enabled' => true,
            ],
        ]);

        // Sauvegarder l'ID du PaymentIntent
        $order->update([
            'stripe_payment_intent_id' => $paymentIntent->id,
            'payment_status' => 'pending'
        ]);

        return $paymentIntent;
    }

    /**
     * Cr√©er un PaymentIntent pour une location (PAIEMENT IMM√âDIAT)
     */
    public function createPaymentIntentForRental(OrderLocation $orderLocation): array
    {
        // √âTAPE 1 : Paiement imm√©diat de la location (sans caution)
        $paymentIntent = PaymentIntent::create([
            'amount' => $this->convertToStripeAmount($orderLocation->total_amount),
            'currency' => 'eur',
            'description' => "Location #{$orderLocation->order_number} - Paiement location",
            'metadata' => [
                'order_id' => $orderLocation->id,
                'order_type' => 'rental',
                'payment_type' => 'rental_payment',
                'order_number' => $orderLocation->order_number,
                'user_id' => $orderLocation->user_id,
                'user_email' => $orderLocation->user->email ?? ''
            ],
            'automatic_payment_methods' => [
                'enabled' => true,
                'allow_redirects' => 'never'
            ],
        ]);

        // √âTAPE 2 : Pr√©autorisation de la caution (si > 0)
        $depositAuthorization = null;
        $depositAuthorizationId = null;
        if ($orderLocation->deposit_amount > 0) {
            $depositAuthorization = $this->createDepositAuthorization($orderLocation);
            $depositAuthorizationId = $depositAuthorization ? $depositAuthorization->id : null;
        }

        // Sauvegarder les IDs des PaymentIntents
        $orderLocation->update([
            'stripe_payment_intent_id' => $paymentIntent->id,
            'stripe_deposit_authorization_id' => $depositAuthorizationId,
            'payment_status' => 'pending'
        ]);

        // Retourner les informations pour le frontend
        return [
            'success' => true,
            'rental_payment_intent_id' => $paymentIntent->id,
            'rental_client_secret' => $paymentIntent->client_secret,
            'rental_amount' => $this->convertFromStripeAmount($paymentIntent->amount),
            'deposit_authorization_id' => $depositAuthorizationId,
            'deposit_client_secret' => $depositAuthorization ? $depositAuthorization->client_secret : null,
            'deposit_amount' => $orderLocation->deposit_amount,
            'order_location_id' => $orderLocation->id,
            'order_number' => $orderLocation->order_number
        ];
    }

    /**
     * Cr√©er une pr√©autorisation pour la caution (CAPTURE MANUELLE)
     */
    public function createDepositAuthorization(OrderLocation $orderLocation): ?PaymentIntent
    {
        if ($orderLocation->deposit_amount <= 0) {
            return null;
        }

        try {
            $authorizationIntent = PaymentIntent::create([
                'amount' => $this->convertToStripeAmount($orderLocation->deposit_amount),
                'currency' => 'eur',
                'capture_method' => 'manual', // üîë PR√âAUTORISATION !
                'description' => "Caution #{$orderLocation->order_number} - Pr√©autorisation",
                'metadata' => [
                    'order_id' => $orderLocation->id,
                    'order_type' => 'rental',
                    'payment_type' => 'deposit_authorization',
                    'order_number' => $orderLocation->order_number,
                    'user_id' => $orderLocation->user_id,
                    'user_email' => $orderLocation->user->email ?? '',
                    'deposit_amount' => $orderLocation->deposit_amount
                ],
                'automatic_payment_methods' => [
                    'enabled' => true,
                    'allow_redirects' => 'never'
                ],
            ]);

            Log::info('Pr√©autorisation caution cr√©√©e', [
                'order_location_id' => $orderLocation->id,
                'deposit_authorization_id' => $authorizationIntent->id,
                'deposit_amount' => $orderLocation->deposit_amount
            ]);

            return $authorizationIntent;
        } catch (\Exception $e) {
            Log::error('Erreur cr√©ation pr√©autorisation caution', [
                'order_location_id' => $orderLocation->id,
                'error' => $e->getMessage()
            ]);
            return null;
        }
    }

    /**
     * G√©rer un paiement r√©ussi
     */
    public function handleSuccessfulPayment(string $paymentIntentId): array
    {
        try {
            $paymentIntent = PaymentIntent::retrieve($paymentIntentId);
            $metadata = $paymentIntent->metadata->toArray();

            if ($metadata['order_type'] === 'purchase') {
                $orderId = (int)$metadata['order_id'];
                $this->processSuccessfulPurchase($orderId, $paymentIntent);
                
                $order = \App\Models\Order::find($orderId);
                return [
                    'success' => true,
                    'order_type' => 'purchase',
                    'order_id' => $orderId,
                    'order_number' => $order?->order_number,
                    'redirect_url' => route('orders.confirmation', $orderId)
                ];
            } elseif ($metadata['order_type'] === 'rental') {
                $orderLocationId = (int)$metadata['order_id'];
                
                // D√©terminer le type de paiement (location ou caution)
                $paymentType = $metadata['payment_type'] ?? 'rental_payment';
                
                if ($paymentType === 'rental_payment') {
                    // Paiement de la location confirm√©
                    $this->processSuccessfulRental($orderLocationId, $paymentIntent);
                } elseif ($paymentType === 'deposit_authorization') {
                    // Pr√©autorisation de caution confirm√©e
                    $this->processSuccessfulDepositAuthorization($orderLocationId, $paymentIntent);
                }
                
                $orderLocation = \App\Models\OrderLocation::find($orderLocationId);
                return [
                    'success' => true,
                    'order_type' => 'rental',
                    'order_id' => $orderLocationId,
                    'order_number' => $orderLocation?->order_number,
                    'redirect_url' => route('rental.payment.success', $orderLocationId),
                    'payment_type' => $paymentType
                ];
            }

            return ['success' => false, 'error' => 'Type de commande inconnu'];
        } catch (\Exception $e) {
            Log::error('Erreur lors du traitement d\'un paiement r√©ussi', [
                'payment_intent_id' => $paymentIntentId,
                'error' => $e->getMessage()
            ]);
            return ['success' => false, 'error' => $e->getMessage()];
        }
    }

    /**
     * Traiter un achat r√©ussi
     */
    private function processSuccessfulPurchase(int $orderId, PaymentIntent $paymentIntent): void
    {
        $order = Order::findOrFail($orderId);
        
        // Mettre √† jour les informations de paiement
        $order->update([
            'payment_status' => 'paid',
            'paid_at' => now(),
            'stripe_payment_intent_id' => $paymentIntent->id,
            'payment_method' => 'stripe',
            'payment_details' => [
                'stripe_payment_intent_id' => $paymentIntent->id,
                'amount_paid' => $this->convertFromStripeAmount($paymentIntent->amount),
                'currency' => $paymentIntent->currency,
                'paid_at' => now()->toISOString()
            ]
        ]);

        // ‚úÖ NOUVEAU SYST√àME NON-BLOQUANT : Progression via le mod√®le Order
        Log::info("D√©marrage progression non-bloquante pour commande {$order->order_number}");
        
        // Passer √† confirmed et d√©clencher les transitions automatiques
        $order->updateStatus('confirmed');
        
        // üöÄ D√©marrer automatiquement le worker de queue si n√©cessaire
        \App\Services\QueueWorkerService::ensureWorkerIsRunning();
        
        Log::info("Commande {$order->order_number} confirm√©e - Transitions automatiques d√©marr√©es");

        // D√©cr√©menter le stock des produits
        foreach ($order->items as $item) {
            $product = $item->product;
            if ($product && $product->quantity >= $item->quantity) {
                $newQuantity = $product->quantity - $item->quantity;
                $product->update(['quantity' => $newQuantity]);
                
                Log::info('Stock d√©cr√©ment√© apr√®s paiement', [
                    'product_id' => $product->id,
                    'product_name' => $product->name,
                    'previous_quantity' => $product->quantity + $item->quantity,
                    'new_quantity' => $newQuantity,
                    'decremented_by' => $item->quantity,
                    'order_id' => $order->id
                ]);
            }
        }

        Log::info('Commande d\'achat pay√©e avec succ√®s', [
            'order_id' => $order->id,
            'order_number' => $order->order_number,
            'amount' => $order->total_amount
        ]);
    }

    /**
     * Traiter une location r√©ussie - g√®re les deux types de paiement (location et caution)
     */
    private function processSuccessfulRental(int $orderLocationId, PaymentIntent $paymentIntent): void
    {
        $orderLocation = OrderLocation::findOrFail($orderLocationId);
        $metadata = $paymentIntent->metadata ?? [];
        $paymentType = $metadata['payment_type'] ?? 'rental_payment';
        
        if ($paymentType === 'rental_payment') {
            // Traitement du paiement de location
            $orderLocation->update([
                'payment_status' => 'paid',
                'status' => 'confirmed',
                'confirmed_at' => now(),
                'paid_at' => now(),
                'stripe_payment_intent_id' => $paymentIntent->id,
                'payment_method' => 'stripe',
                'payment_details' => [
                    'stripe_payment_intent_id' => $paymentIntent->id,
                    'amount_paid' => $this->convertFromStripeAmount($paymentIntent->amount),
                    'currency' => $paymentIntent->currency,
                    'paid_at' => now()->toISOString()
                ]
            ]);

            // ‚ö†Ô∏è IMPORTANT: Le stock sera d√©cr√©ment√© SEULEMENT quand l'utilisateur confirmera c√¥t√© frontend
            // Cela √©vite le d√©cr√©ment pr√©matur√© si l'utilisateur quitte avant la page de succ√®s
            Log::info('Paiement webhook trait√© - Stock sera d√©cr√©ment√© lors de la confirmation frontend', [
                'order_location_id' => $orderLocation->id,
                'payment_confirmed' => true,
                'frontend_confirmed' => $orderLocation->frontend_confirmed ?? false,
                'note' => 'Stock NON d√©cr√©ment√© ici - attente confirmation frontend'
            ]);

            // Programmer les t√¢ches automatiques pour cette location
            $this->scheduleRentalTasks($orderLocation);
            
            Log::info("Paiement de location trait√© avec succ√®s", [
                'order_location_id' => $orderLocationId,
                'payment_intent_id' => $paymentIntent->id,
                'amount' => $paymentIntent->amount / 100
            ]);
            
        } elseif ($paymentType === 'deposit_authorization') {
            // Traitement de la pr√©autorisation de caution
            $orderLocation->update([
                'stripe_deposit_authorization_id' => $paymentIntent->id,
                'deposit_status' => 'authorized'
            ]);
            
            Log::info("Pr√©autorisation de caution trait√©e avec succ√®s", [
                'order_location_id' => $orderLocationId,
                'authorization_id' => $paymentIntent->id,
                'amount' => $paymentIntent->amount / 100
            ]);
        }

        Log::info('Location pay√©e avec succ√®s', [
            'order_location_id' => $orderLocation->id,
            'order_number' => $orderLocation->order_number,
            'amount' => $orderLocation->total_amount,
            'rental_period' => $orderLocation->start_date->format('Y-m-d') . ' - ' . $orderLocation->end_date->format('Y-m-d')
        ]);
    }

    /**
     * Programmer les t√¢ches automatiques pour une location
     */
    private function scheduleRentalTasks(OrderLocation $orderLocation): void
    {
        try {
            // Programmer les notifications selon les dates de location
            $this->scheduleRentalNotifications($orderLocation);

            Log::info('T√¢ches de location programm√©es (email g√©r√© par le listener)', [
                'order_location_id' => $orderLocation->id,
                'user_email' => $orderLocation->user->email
            ]);

        } catch (\Exception $e) {
            Log::error('Erreur lors de la programmation des t√¢ches de location', [
                'order_location_id' => $orderLocation->id,
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Programmer les notifications automatiques de location
     */
    private function scheduleRentalNotifications(OrderLocation $orderLocation): void
    {
        $startDate = $orderLocation->start_date;
        $endDate = $orderLocation->end_date;
        $now = now();

        // Notification de d√©but de location (si la location commence dans le futur)
        if ($startDate->isAfter($now)) {
            // Job pour marquer la location comme "en cours" au d√©but
            \App\Jobs\StartRentalJob::dispatch($orderLocation)->delay($startDate);
            
            Log::info('Job de d√©but de location programm√©', [
                'order_location_id' => $orderLocation->id,
                'scheduled_for' => $startDate->toISOString()
            ]);
        } elseif ($startDate->isToday() || $startDate->isPast()) {
            // Si la location commence aujourd'hui ou √©tait cens√©e commencer avant, la marquer comme en cours
            $orderLocation->update([
                'status' => 'active',
                'started_at' => $startDate->isPast() ? $startDate : now()
            ]);
        }

        // Notification de rappel 1 jour avant la fin
        $reminderDate = $endDate->copy()->subDay();
        if ($reminderDate->isAfter($now)) {
            \App\Jobs\RentalEndReminderJob::dispatch($orderLocation)->delay($reminderDate);
            
            Log::info('Job de rappel de fin de location programm√©', [
                'order_location_id' => $orderLocation->id,
                'scheduled_for' => $reminderDate->toISOString()
            ]);
        }

        // Notification de fin de location et demande de retour
        if ($endDate->isAfter($now)) {
            \App\Jobs\EndRentalJob::dispatch($orderLocation)->delay($endDate);
            
            Log::info('Job de fin de location programm√©', [
                'order_location_id' => $orderLocation->id,
                'scheduled_for' => $endDate->toISOString()
            ]);
        }

        // Notification de retard si applicable (1 jour apr√®s la fin)
        $overdueDate = $endDate->copy()->addDay();
        if ($overdueDate->isAfter($now)) {
            \App\Jobs\RentalOverdueJob::dispatch($orderLocation)->delay($overdueDate);
            
            Log::info('Job de retard de location programm√©', [
                'order_location_id' => $orderLocation->id,
                'scheduled_for' => $overdueDate->toISOString()
            ]);
        }
    }

    /**
     * Annuler une commande et rembourser le stock
     */
    public function cancelOrderAndRefundStock(Order $order): bool
    {
        try {
            DB::beginTransaction();

            // Ne restaurer le stock QUE si la commande √©tait confirm√©e/pay√©e 
            // (et donc le stock avait √©t√© pr√©lev√©)
            $shouldRestoreStock = in_array($order->status, ['confirmed', 'processing', 'shipped', 'delivered']);
            
            if ($shouldRestoreStock) {
                Log::info('Restoration du stock car commande √©tait confirm√©e', [
                    'order_id' => $order->id,
                    'order_status' => $order->status
                ]);
                
                // Restaurer le stock pour chaque item
                foreach ($order->items as $item) {
                    $product = $item->product;
                    if ($product) {
                        $product->increment('quantity', $item->quantity);
                        
                        Log::info('Stock restaur√© lors de l\'annulation', [
                            'product_id' => $product->id,
                            'product_name' => $product->name,
                            'previous_quantity' => $product->quantity - $item->quantity,
                            'new_quantity' => $product->quantity,
                            'restored_by' => $item->quantity,
                            'order_id' => $order->id
                        ]);
                    }
                }
            } else {
                Log::info('Pas de restoration de stock car commande √©tait en attente', [
                    'order_id' => $order->id,
                    'order_status' => $order->status,
                    'note' => 'Le stock n\'avait jamais √©t√© pr√©lev√©'
                ]);
            }

            // Mettre √† jour le statut de la commande
            $order->update([
                'status' => 'cancelled',
                'cancelled_at' => now()
            ]);

            DB::commit();
            
            Log::info('Commande annul√©e avec succ√®s', [
                'order_id' => $order->id,
                'order_number' => $order->order_number,
                'stock_restored' => $shouldRestoreStock
            ]);

            return true;
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('Erreur lors de l\'annulation de la commande', [
                'order_id' => $order->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Traiter le retour d'une location
     */
    public function processRentalReturn(OrderLocation $orderLocation): bool
    {
        try {
            DB::beginTransaction();

            // Restaurer le stock pour chaque item de location
            foreach ($orderLocation->items as $item) {
                $product = $item->product;
                if ($product) {
                    $product->increment('quantity', $item->quantity);
                    
                    Log::info('Stock restaur√© lors du retour de location', [
                        'product_id' => $product->id,
                        'product_name' => $product->name,
                        'previous_quantity' => $product->quantity - $item->quantity,
                        'new_quantity' => $product->quantity,
                        'restored_by' => $item->quantity,
                        'order_location_id' => $orderLocation->id
                    ]);
                }
            }

            // Mettre √† jour le statut de la location
            $orderLocation->update([
                'status' => 'finished',
                'returned_at' => now()
            ]);

            DB::commit();
            
            Log::info('Location retourn√©e avec succ√®s', [
                'order_location_id' => $orderLocation->id,
                'order_number' => $orderLocation->order_number
            ]);

            return true;
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('Erreur lors du retour de location', [
                'order_location_id' => $orderLocation->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * G√©rer les webhooks Stripe
     */
    public function handleWebhook(string $payload, string $signature): bool
    {
        try {
            $event = Webhook::constructEvent(
                $payload,
                $signature,
                config('services.stripe.webhook.secret')
            );

            // Log de TOUS les √©v√©nements re√ßus
            error_log("üéØ WEBHOOK RE√áU: " . $event->type . " - ID: " . $event->id);
            Log::info('Webhook Stripe re√ßu', [
                'event_type' => $event->type,
                'event_id' => $event->id,
                'payment_intent_id' => $event->data->object->id ?? 'N/A',
                'metadata' => $event->data->object->metadata ?? []
            ]);

            switch ($event->type) {
                case 'payment_intent.succeeded':
                    error_log("üí∞ TRAITEMENT payment_intent.succeeded - ID: " . $event->data->object->id);
                    Log::info('üî• PROCESSING payment_intent.succeeded', [
                        'payment_intent_id' => $event->data->object->id,
                        'metadata' => $event->data->object->metadata->toArray()
                    ]);
                    $this->handleSuccessfulPayment($event->data->object->id);
                    break;
                
                case 'payment_intent.payment_failed':
                    error_log("‚ùå TRAITEMENT payment_intent.payment_failed");
                    $this->handleFailedPayment($event->data->object->id);
                    break;
                
                case 'payment_intent.created':
                    error_log("üìù TRAITEMENT payment_intent.created - PAS D'ACTION");
                    break;
                
                default:
                    error_log("‚ùì WEBHOOK NON G√âR√â: " . $event->type);
            }

            return true;
        } catch (\Exception $e) {
            error_log("üí• ERREUR WEBHOOK: " . $e->getMessage());
            return false;
        }
    }

    /**
     * G√©rer un paiement √©chou√©
     */
    private function handleFailedPayment(string $paymentIntentId): void
    {
        try {
            $paymentIntent = PaymentIntent::retrieve($paymentIntentId);
            $metadata = $paymentIntent->metadata->toArray();

            if ($metadata['order_type'] === 'purchase') {
                $order = Order::find($metadata['order_id']);
                if ($order) {
                    $order->update(['payment_status' => 'failed']);
                }
            } elseif ($metadata['order_type'] === 'rental') {
                $orderLocation = OrderLocation::find($metadata['order_id']);
                if ($orderLocation) {
                    $orderLocation->update(['payment_status' => 'failed']);
                }
            }

            Log::warning('Paiement Stripe √©chou√©', [
                'payment_intent_id' => $paymentIntentId,
                'order_type' => $metadata['order_type'] ?? 'unknown',
                'order_id' => $metadata['order_id'] ?? 'unknown'
            ]);

        } catch (\Exception $e) {
            Log::error('Erreur lors du traitement d\'un paiement √©chou√©', [
                'payment_intent_id' => $paymentIntentId,
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Convertir un montant en centimes pour Stripe
     */
    public function convertToStripeAmount(float $amount): int
    {
        return (int) round($amount * 100);
    }

    /**
     * Convertir un montant Stripe en euros
     */
    public function convertFromStripeAmount(int $stripeAmount): float
    {
        return $stripeAmount / 100;
    }

    /**
     * Annuler une location et rembourser le stock
     */
    public function cancelRentalAndRefundStock(OrderLocation $orderLocation): bool
    {
        try {
            DB::beginTransaction();

            // V√©rifier si la location peut √™tre annul√©e (avant le d√©but)
            $canCancel = now()->lt($orderLocation->start_date);
            
            $cancellationReason = $canCancel ? 'cancelled_before_start' : 'cancelled_during_rental';
            
            // Utiliser la m√©thode cancel du mod√®le qui g√®re correctement le stock
            $orderLocation->cancel($cancellationReason);

            DB::commit();
            
            Log::info('Location annul√©e avec succ√®s', [
                'order_location_id' => $orderLocation->id,
                'order_number' => $orderLocation->order_number,
                'cancelled_before_start' => $canCancel,
                'stock_restored' => $canCancel
            ]);

            return true;
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('Erreur lors de l\'annulation de location', [
                'order_location_id' => $orderLocation->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Traiter un remboursement automatique pour une commande retourn√©e
     */
    public function processAutomaticRefund(Order $order): bool
    {
        try {
            if (!$order->stripe_payment_intent_id) {
                Log::error('Impossible de rembourser: aucun PaymentIntent trouv√©', [
                    'order_id' => $order->id,
                    'order_number' => $order->order_number
                ]);
                return false;
            }

            // Cr√©er le remboursement via Stripe
            $refund = \Stripe\Refund::create([
                'payment_intent' => $order->stripe_payment_intent_id,
                'amount' => $this->convertToStripeAmount($order->total_amount),
                'reason' => 'requested_by_customer',
                'metadata' => [
                    'order_id' => $order->id,
                    'order_number' => $order->order_number,
                    'refund_type' => 'automatic_return',
                    'user_id' => $order->user_id,
                    'return_reason' => $order->return_reason ?? 'Retour automatique'
                ]
            ]);

            // Mettre √† jour la commande
            $order->update([
                'refund_processed' => true,
                'refund_amount' => $this->convertFromStripeAmount($refund->amount),
                'refund_id' => $refund->id,
                'refunded_at' => now()
            ]);

            Log::info('Remboursement automatique trait√©', [
                'order_id' => $order->id,
                'refund_id' => $refund->id,
                'amount' => $refund->amount / 100
            ]);

            return true;
                
        } catch (\Exception $e) {
            Log::error('Erreur lors du traitement du remboursement automatique', [
                'order_id' => $order->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Capturer une pr√©autorisation de caution (en cas de dommages)
     */
    public function captureDepositAuthorization(OrderLocation $orderLocation, float $amount = null): bool
    {
        try {
            if (!$orderLocation->stripe_deposit_authorization_id) {
                Log::error('Impossible de capturer: aucune pr√©autorisation trouv√©e', [
                    'order_location_id' => $orderLocation->id,
                    'order_number' => $orderLocation->order_number
                ]);
                return false;
            }

            // R√©cup√©rer le PaymentIntent de pr√©autorisation
            $paymentIntent = PaymentIntent::retrieve($orderLocation->stripe_deposit_authorization_id);
            
            // Si pas de montant sp√©cifi√©, capturer le montant total autoris√©
            if ($amount === null) {
                $captureAmount = $paymentIntent->amount;
            } else {
                $captureAmount = $this->convertToStripeAmount($amount);
                // S'assurer que le montant ne d√©passe pas l'autorisation
                if ($captureAmount > $paymentIntent->amount) {
                    $captureAmount = $paymentIntent->amount;
                }
            }

            // Capturer le paiement
            $capturedPayment = $paymentIntent->capture([
                'amount_to_capture' => $captureAmount
            ]);

            // Mettre √† jour la location
            $orderLocation->update([
                'deposit_status' => 'captured',
                'deposit_captured_amount' => $this->convertFromStripeAmount($captureAmount),
                'deposit_captured_at' => now()
            ]);

            Log::info('Pr√©autorisation de caution captur√©e', [
                'order_location_id' => $orderLocation->id,
                'authorization_id' => $orderLocation->stripe_deposit_authorization_id,
                'captured_amount' => $captureAmount / 100
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error('Erreur lors de la capture de pr√©autorisation', [
                'order_location_id' => $orderLocation->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Annuler une pr√©autorisation de caution (retour sans dommages)
     */
    public function cancelDepositAuthorization(OrderLocation $orderLocation): bool
    {
        try {
            if (!$orderLocation->stripe_deposit_authorization_id) {
                Log::error('Impossible d\'annuler: aucune pr√©autorisation trouv√©e', [
                    'order_location_id' => $orderLocation->id,
                    'order_number' => $orderLocation->order_number
                ]);
                return false;
            }

            // R√©cup√©rer et annuler le PaymentIntent
            $paymentIntent = PaymentIntent::retrieve($orderLocation->stripe_deposit_authorization_id);
            $cancelledPayment = $paymentIntent->cancel();

            // Mettre √† jour la location
            $orderLocation->update([
                'deposit_status' => 'cancelled',
                'deposit_cancelled_at' => now()
            ]);

            Log::info('Pr√©autorisation de caution annul√©e', [
                'order_location_id' => $orderLocation->id,
                'authorization_id' => $orderLocation->stripe_deposit_authorization_id
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error('Erreur lors de l\'annulation de pr√©autorisation', [
                'order_location_id' => $orderLocation->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * D√©cr√©menter le stock quand l'utilisateur confirme c√¥t√© frontend
     */
    public function decrementStockOnFrontendConfirmation(OrderLocation $orderLocation): bool
    {
        if ($orderLocation->frontend_confirmed) {
            Log::info('Stock d√©j√† d√©cr√©ment√© pour cette commande', [
                'order_location_id' => $orderLocation->id,
                'order_number' => $orderLocation->order_number
            ]);
            return true;
        }

        $success = true;
        
        // D√©cr√©menter le stock de location des produits
        foreach ($orderLocation->items as $item) {
            $product = $item->product;
            if ($product && $product->rental_stock >= $item->quantity) {
                $newRentalStock = $product->rental_stock - $item->quantity;
                $product->update(['rental_stock' => $newRentalStock]);
                
                Log::info('Stock de location d√©cr√©ment√© (confirmation frontend)', [
                    'product_id' => $product->id,
                    'product_name' => $product->name,
                    'previous_rental_stock' => $product->rental_stock + $item->quantity,
                    'new_rental_stock' => $newRentalStock,
                    'decremented_by' => $item->quantity,
                    'order_location_id' => $orderLocation->id,
                    'rental_period' => $orderLocation->start_date->format('Y-m-d') . ' - ' . $orderLocation->end_date->format('Y-m-d')
                ]);
            } else {
                Log::warning('Stock de location insuffisant lors de la confirmation frontend', [
                    'product_id' => $product?->id,
                    'product_name' => $product?->name,
                    'available_rental_stock' => $product?->rental_stock,
                    'requested_quantity' => $item->quantity
                ]);
                $success = false;
            }
        }

        if ($success) {
            // Marquer comme confirm√© c√¥t√© frontend
            $orderLocation->update([
                'frontend_confirmed' => true,
                'frontend_confirmed_at' => now()
            ]);
            
            Log::info('Commande confirm√©e c√¥t√© frontend avec d√©cr√©ment de stock', [
                'order_location_id' => $orderLocation->id,
                'order_number' => $orderLocation->order_number
            ]);
        }

        return $success;
    }
}
